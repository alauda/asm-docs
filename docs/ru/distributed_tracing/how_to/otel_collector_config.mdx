---
weight: 40
sourceSHA: 52204ef1b12e2906059865bf5954364bf030810e22d28809fdd9353aca7c7845
---

# Настройка OpenTelemetry Collector

## Обзор функций

Вы можете настроить OpenTelemetry Collector в соответствии с вашими потребностями в наблюдаемости. Прежде чем углубляться в детали конфигурации Collector, важно ознакомиться со следующими материалами:

- [Концепции сбора данных](https://opentelemetry.io/docs/concepts/components/#collector), чтобы понять репозиторий, применимый к OpenTelemetry Collector.
- [Руководство по безопасности](https://github.com/open-telemetry/opentelemetry-collector/blob/main/docs/security-best-practices.md).

## Структура конфигурации

Структура любого файла конфигурации Collector состоит из четырех типов компонентов конвейеров, которые взаимодействуют с телеметрическими данными:

- **[Приемники](#receivers)**
- **[Процессоры](#processors)**
- **[Экспортёры](#exporters)**
- **[Соединители](#connectors)**

После настройки каждого компонента конвейера вы должны включить его через конвейер, определенный в [разделе службы](#service-section) файла конфигурации.

В дополнение к компонентам конвейера, вы можете настроить [Расширения](#extensions), которые предоставляют дополнительные функции, которые можно добавить в Collector, такие как инструменты диагностики. Расширения не требуют прямого доступа к телеметрическим данным и включаются через [раздел службы](#service-section).

Ниже приведен пример конфигурации Collector, которая включает приемники, процессоры, экспортёры и три расширения.

**Важно:** Хотя обычно необходимо привязывать конечные точки к `localhost`, когда все клиенты находятся локально, наша образцовая конфигурация использует "неопределённый" адрес `0.0.0.0` для удобства. По умолчанию Collector использует `localhost`. Для получения подробной информации о значениях конфигурации этих конечных точек смотрите [Меры безопасности для предотвращения атак типа "отказ в обслуживании"](https://github.com/open-telemetry/opentelemetry-collector/blob/main/docs/security-best-practices.md#safeguards-against-denial-of-service-attacks).

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318
processors:
  batch:

exporters:
  otlp:
    endpoint: otelcol:4317

extensions:
  health_check:
  pprof:
  zpages:

service:
  extensions: [health_check, pprof, zpages]
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlp]
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlp]
    logs:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlp]
```

Обратите внимание, что приемники, процессоры, экспортёры и конвейеры определяются с использованием идентификатора компонента в формате `type[/name]`, например, `otlp` или `otlp/2`. Пока идентификатор уникален, вы можете определить один и тот же тип компонента несколько раз. Например:

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318
  otlp/2:
    protocols:
      grpc:
        endpoint: 0.0.0.0:55690

processors:
  batch:
  batch/test:

exporters:
  otlp:
    endpoint: otelcol:4317
  otlp/2:
    endpoint: otelcol2:4317

extensions:
  health_check:
  pprof:
  zpages:

service:
  extensions: [health_check, pprof, zpages]
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlp]
    traces/2:
      receivers: [otlp/2]
      processors: [batch/test]
      exporters: [otlp/2]
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlp]
    logs:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlp]
```

Конфигурация также может включать другие файлы, позволяя Collector объединить их в единую конфигурацию YAML в памяти:

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317

exporters: ${file:exporters.yaml}

service:
  extensions: []
  pipelines:
    traces:
      receivers: [otlp]
      processors: []
      exporters: [otlp]
```

Файл `exporters.yaml` может содержать:

```yaml
otlp:
  endpoint: otelcol.observability.svc.cluster.local:443
```

В результате, конфигурация в памяти будет выглядеть так:

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317

exporters:
  otlp:
    endpoint: otelcol.observability.svc.cluster.local:443

service:
  extensions: []
  pipelines:
    traces:
      receivers: [otlp]
      processors: []
      exporters: [otlp]
```

## Приемники

Приемники собирают телеметрические данные из одного или нескольких источников. Они могут быть основаны на принципе выборки или отправки и могут поддерживать один или несколько [источников данных](https://opentelemetry.io/docs/concepts/signals/).

Как правило, приемник принимает данные в заданном формате, преобразует их во внутренний формат, а затем передает их процессорам и экспортёрам, определенным в соответствующем конвейере.

Приемники настраиваются в разделе `receivers`. По умолчанию ни один приемник не настроен. Вы должны настроить один или несколько приемников. Многие приемники поставляются с настройками по умолчанию, поэтому указания имени приемника может быть достаточно. Если вам нужно настроить или изменить настройки по умолчанию, вы можете сделать это в этом разделе. Любые указанные вами настройки переопределят значения по умолчанию (если они существуют).

**Примечание:** Настройка приемника не включает его. Приемник включается путем добавления его в соответствующий конвейер в [разделе службы](#service-section).

Ниже приведены общие примеры конфигурации приемников.

**Совет:** Для более подробных конфигураций приемников смотрите [README приемника](https://github.com/open-telemetry/opentelemetry-collector/blob/main/receiver/README.md).

### **Приемник OTLP**

Приемник OTLP принимает трассировки, метрики и журналы, используя Протокол OpenTelemetry (OTLP).

**YAML пример**

```yaml
  config: |
    receivers:
      otlp:
        protocols:
          grpc:
            endpoint: 0.0.0.0:4317
            tls:
              ca_file: ca.pem
              cert_file: cert.pem
              key_file: key.pem
              client_ca_file: client.pem
              reload_interval: 1h
          http:
            endpoint: 0.0.0.0:4318

    service:
      pipelines:
        traces:
          receivers: [otlp]
        metrics:
          receivers: [otlp]
```

**Описание параметров `protocols`**

| Параметр                  | Описание                                                                                                                                                                                                                                                         |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `grpc.endpoint`            | Конечная точка OTLP gRPC. Если опущена, по умолчанию используется 0.0.0.0:4317.                                                                                                                                                                                  |
| `grpc.tls`                 | Конфигурация TLS на стороне сервера. Определяет пути к сертификатам TLS. Если опущена, TLS отключен.                                                                                                                                                          |
| `grpc.tls.client_ca_file`  | Путь к TLS сертификату, используемому сервером для проверки клиентских сертификатов. Это устанавливает `ClientCAs` и `ClientAuth` на `RequireAndVerifyClientCert` в `TLSConfig`. Для получения более подробной информации смотрите [Golang TLS Package Config](https://godoc.org/crypto/tls#Config). |
| `grpc.tls.reload_interval` | Указывает интервал для перезагрузки сертификатов. Если не установлен, сертификаты никогда не будут перезагружены. Поле `reload_interval` принимает строку с допустимыми единицами времени, такими как ns, us (или µs), ms, s, m, h.                           |
| `http.endpoint`            | Конечная точка OTLP HTTP. По умолчанию используется 0.0.0.0:4318.                                                                                                                                                                                           |
| `http.tls`                 | Конфигурация TLS на стороне сервера. Настроена аналогично `grpc.tls`.                                                                                                                                                                                         |

### **Приемник Jaeger**

Приемник Jaeger принимает трассировки в формате Jaeger.

**YAML пример**

```yaml
  config: |
    receivers:
      jaeger:
        protocols:
          grpc:
            endpoint: 0.0.0.0:14250
          thrift_http:
            endpoint: 0.0.0.0:14268
          thrift_compact:
            endpoint: 0.0.0.0:6831
          thrift_binary:
            endpoint: 0.0.0.0:6832

    service:
      pipelines:
        traces:
          receivers: [jaeger]
```

**Описание параметров `protocols`**

| Параметр                 | Описание                                                                                                     |
| ------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `grpc.endpoint`           | Конечная точка Jaeger gRPC. Если опущена, по умолчанию используется 0.0.0.0:14250.                          |
| `thrift_http.endpoint`    | Конечная точка Jaeger Thrift HTTP. Если опущена, по умолчанию используется 0.0.0.0:14268.                   |
| `thrift_compact.endpoint` | Конечная точка Jaeger Thrift Compact. Если опущена, по умолчанию используется 0.0.0.0:6831.                  |
| `thrift_binary.endpoint`  | Конечная точка Jaeger Thrift Binary. Если опущена, по умолчанию используется 0.0.0.0:6832.                   |
| `tls`                     | Конфигурация TLS на стороне сервера. Смотрите `protocols.grpc.tls` для получения конфигурационных деталей. |

### **Приемник Zipkin**

Приемник Zipkin принимает трассировки в форматах Zipkin v1 и v2.

**YAML пример**

```yaml
  config: |
    receivers:
      zipkin:
        endpoint: 0.0.0.0:9411

    service:
      pipelines:
        traces:
          receivers: [zipkin]
```

**Описание параметра `zipkin`**

| Параметр  | Описание                                                                                                     |
| ---------- | ------------------------------------------------------------------------------------------------------------- |
| `endpoint` | Конечная точка Zipkin HTTP. Если опущена, по умолчанию используется 0.0.0.0:9411.                           |
| `tls`      | Конфигурация TLS на стороне сервера. Смотрите `protocols.grpc.tls` для получения конфигурационных деталей. |

## Процессоры

Процессоры изменяют или преобразуют данные, собранные приемниками, перед отправкой их экспортёрам. Обработка данных основывается на правилах или настройках, определенных для каждого процессора, которые могут включать фильтрацию, удаление, переименование или перерасчет телеметрических данных. Порядок процессоров в конвейере определяет последовательность применения операций обработки Collector к сигналам.

Процессоры являются необязательными, но некоторые из них являются [рекомендуемыми](https://github.com/open-telemetry/opentelemetry-collector/tree/main/processor#recommended-processors).

Вы можете настраивать процессоры в разделе `processors` файла конфигурации Collector. Любые указанные вами настройки переопределяют значения по умолчанию (если они существуют).

**Примечание:** Настройка процессора не включает его. Процессор необходимо включить, добавив его в соответствующий конвейер в [разделе службы](#service-section). По умолчанию ни один процессор не включен.

Ниже приведены примеры общих конфигураций процессоров.

**Совет:** Полный список процессоров можно найти, объединив списки из [opentelemetry-collector-contrib](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor) и [opentelemetry-collector](https://github.com/open-telemetry/opentelemetry-collector/tree/main/processor). Для более подробных конфигураций процессоров смотрите [README процессора](https://github.com/open-telemetry/opentelemetry-collector/blob/main/processor/README.md).

### **Процессор Batch**

Процессор Batch объединяет и сжимает спаны, метрики или журналы на основе размера или времени. Объединение данных может помочь уменьшить количество запросов на отправку, сделанных экспортёрами, и помочь регулировать поток телеметрии от нескольких или одного приемника в конвейере.

**YAML пример**

```yaml
  config: |
    processor:
      batch:
        timeout: 5s
        send_batch_max_size: 10000
    service:
      pipelines:
        traces:
          processors: [batch]
        metrics:
          processors: [batch]
```

**Описание параметров `batch`**

| Параметр                    | Описание                                                                                                                                                       |
| ---------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `timeout`                    | Отправляет пакеты после определенного времени, независимо от размера пакета.                                                                                  |
| `send_batch_size`            | Отправляет пакеты телеметрических данных после определенного количества спанов или метрик.                                                                        |
| `send_batch_max_size`        | Максимально допустимый размер пакета. Должен быть равен или больше `send_batch_size`.                                                                          |
| `metadata_keys`              | При включении создает экземпляр пакета для каждого уникального набора значений, найденных в client.Metadata.                                                    |
| `metadata_cardinality_limit` | Когда `metadata_keys` заполнен, эта конфигурация ограничивает количество различных комбинаций пар ключ-значение метаданных, обрабатываемых за период обработки. |

### **Процессор ограничения памяти**

Процессор ограничения памяти периодически проверяет использование памяти Collector и приостанавливает обработку данных, когда достигается мягкий лимит памяти, предотвращая ситуации, когда память исчерпана. Этот процессор поддерживает спаны, метрики и журналы. Обычно он является первым компонентом после приемников, ожидая повторной отправки одних и тех же данных и, возможно, применяя обратное давление к входящим данным. Когда использование памяти превышает жесткий лимит, процессор ограничения памяти инициирует сборку мусора.

**YAML пример**

```yaml
  config: |
    processor:
      memory_limiter:
        check_interval: 1s
        limit_mib: 4000
        spike_limit_mib: 800
    service:
      pipelines:
        traces:
          processors: [batch]
        metrics:
          processors: [batch]
```

**Описание параметров `memory_limiter`**

| Параметр                | Описание                                                                                                                                                                                                       |
| ------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `check_interval`         | Интервал времени между измерениями использования памяти. Оптимальное значение - 1 секунда. Для сильно колеблющихся графиков трафика, вы можете уменьшить `check_interval` или увеличить `spike_limit_mib`.        |
| `limit_mib`              | Жесткий лимит, т.е. максимальный объём памяти, выделяемый в куче (в MiB). Обычно общее использование памяти OpenTelemetry Collector примерно на 50 MiB больше этого значения.                                  |
| `spike_limit_mib`        | Лимит скачков, т.е. ожидаемое максимальное значение для скачков использования памяти (в MiB). Оптимальное значение - около 20% от `limit_mib`. Мягкий лимит рассчитывается путем вычитания `spike_limit_mib` из `limit_mib`. |
| `limit_percentage`       | То же самое, что и `limit_mib`, но выражается в процентах от общей доступной памяти. Параметр `limit_mib` имеет приоритет над этим параметром.                                                                |
| `spike_limit_percentage` | То же самое, что и `spike_limit_mib`, но выражается в процентах от общей доступной памяти. Предназначено для совместного использования с параметром `limit_percentage`.                                          |

### **Процессор фильтрации**

Процессор фильтрации фильтрует спаны, метрики или журналы на основе условий, которые вы определяете в его конфигурации. Обычный случай использования процессора фильтрации — отклонять телеметрические данные, не имеющие значения для системы наблюдаемости, такие как не критические журналы или спаны, чтобы уменьшить уровень "шума" в данных.

Фильтрация работает с помощью списков разрешений и запретов, которые включают или исключают телеметрию на основе регулярных выражений и атрибутов ресурсов. Вы также можете использовать Язык преобразования OpenTelemetry (OTTL), чтобы лучше описать сигналы, которые вы хотите отфильтровать. Процессор поддерживает все типы конвейеров.

| Сигнал      | Критерии и типы сопоставления                                                                                                                    |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| **Спаны**   | Условия OTTL, имена спанов (строгое или регулярное выражение) и атрибуты ресурсов (строгое или регулярное выражение). Фильтрация событий спана поддерживает только условия OTTL. |
| **Метрики** | Условия OTTL, имена метрик (строгое или регулярное выражение) и атрибуты метрик (выражения). Фильтрация точек данных поддерживает только условия OTTL.    |
| **Журналы**  | Условия OTTL, атрибуты ресурсов (строгое или регулярное выражение).                                                                               |

**YAML пример**

```yaml
config: |
  processors:
    filter/ottl:
      error_mode: ignore
      traces:
        span:
          - 'attributes["container.name"] == "app_container_1"'
          - 'resource.attributes["host.name"] == "localhost"'
```

**Описание параметров `filter/ottl`**

| Параметр    | Описание                                                                                                                                                                                                                     |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `error_mode` | Определяет режим обработки ошибок. При установленном в ignore, игнорирует ошибки, возвращенные условиями. При установленном в propagate, возвращает ошибки на верхние уровни конвейера. Ошибки приведут к потере данных от Collector. |
| `span[0]`    | Фильтрует спаны с атрибутом `container.name == app_container_1`.                                                                                                                                                           |
| `span[1]`    | Фильтрует спаны с атрибутом ресурса `host.name == localhost`.                                                                                                                                                             |

### **Процессор преобразования метрик**

Процессор преобразования метрик имеет некоторые общие функции с процессором атрибутов и обычно используется для выполнения следующих задач:

- Добавление, переименование или удаление ключей и значений меток.
- Масштабирование и агрегирование метрик на основе меток или значений меток.
- Процессор поддерживает только переименование и агрегирование в рамках одной партии метрик. Он не выполняет агрегирование между партиями, поэтому не используйте его для агрегирования метрик из нескольких источников, таких как несколько узлов или клиентов.

Для получения полного списка поддерживаемых операций смотрите [Доступные операции](#available-ops).

**YAML пример**

```yaml
config: |
  processors:
    metricstransform/rename:
      transforms:
        include: system.cpu.usage
        action: update
        new_name: system.cpu.usage_time
```

Процессор преобразования метрик также поддерживает использование регулярных выражений, позволяя применять правила преобразования ко множеству имен метрик или меток метрик одновременно. Следующий пример переименовывает `cluster_name` в `cluster-name` во всех метриках:

```yaml
config: |
  processors:
    metricstransform/clustername:
      transforms:
        - include: ^.*$
          match_type: regexp
          action: update
          operations:
            - action: update_label
              label: cluster_name
              new_label: cluster-name
```

**<span id="available-ops">Доступные операции</span>**

Процессор может выполнять следующие операции:

- Переименование метрик. Например, переименование `system.cpu.usage` в `system.cpu.usage_time`.
- Добавление меток. Например, вы можете добавить новую метку `identifier` со значением `1` ко всем точкам.
- Переименование ключей меток. Например, переименование метки `state` в `cpu_state`.
- Переименование значений меток. Например, переименование значения `idle` в `-` внутри метки `state`.
- Удаление точек данных. Например, удаление всех точек, где метка `state` имеет значение `idle`.
- Изменение типов данных. Вы можете изменить точки данных `int` на точки данных `double`.
- Масштабирование значений. Например, умножение значений на 1000 для преобразования из секунд в миллисекунды.
- Агрегирование по наборам меток. Например, сохранение только метки `state` и усреднение всех точек с одинаковым значением для этой метки.
- Агрегирование по значениям меток. Например, суммирование точек со значениями `user` или `system` в метке `state` как `used = user + system`.

Следующие правила применимы:

- Вы можете применять операции только к одной или нескольким метрикам, используя строгий или регулярный фильтр.
- Используя свойство `action`, вы можете:
  - Обновить свои метрики на месте (`update`).
  - Дублировать и обновить дублированные метрики (`insert`).
  - Объединить свои метрики в новую вставленную метрику, объединив все точки данных из набора совпадающих метрик в одну метрику (`combine`). Изначально совпадающие метрики также удаляются.
- При переименовании метрик группы захвата в фильтре `regexp` будут расширены.

### **Процессор преобразования**

Процессор преобразования изменяет совпадающие спаны, метрики или журналы с помощью заявлений. Примеры использования включают, но не ограничиваются, преобразованием метрик в разные типы, заменой или удалением ключей и установкой полей на основе предопределенных условий.

Заявления являются функциями на Языке преобразования OpenTelemetry (OTTL) и применяются к телеметрическим данным в соответствии с их порядком в списке. Процессор преобразования включает дополнительные функции для преобразования типов метрик. Заявления преобразуют данные в зависимости от контекста OTTL, который вы определяете, например, Span или DataPoint.

Поддерживаемые контексты для процессора преобразования:

| Сигнал      | Поддерживаемые контексты                   |
| ----------- | ---------------------------------------- |
| **Трассировки**  | ресурс → область → спан → событие спана   |
| **Метрики** | ресурс → область → метрика → точка данных |
| **Журналы**  | ресурс → область → журналы                |

Заявления могут преобразовывать телеметрические данные в контексте более высокого уровня. Например, заявление, примененное к точке данных, может получить доступ к метрике и ресурсу этой точки данных. Более низкие контексты недоступны; например, вы не можете использовать заявление спана для преобразования отдельных событий спана. Обычно заявления ассоциируются с контекстом, который вы хотите преобразовать.

Пример использования процессора преобразования для установки статуса спана. Следующий пример устанавливает статус спана на `Ok`, когда атрибут `http.request.status_code` равен 400:

**YAML пример**

```yaml
config: |
  transform:
    error_mode: ignore
    trace_statements:
      - context: span
        statements:
          - set(status.code, STATUS_CODE_OK) where attributes["http.request.status_code"] == 400
```

Поле `error_mode` описывает, как процессор реагирует на ошибки при обработке заявлений:

- `"error_mode: ignore"` говорит процессору игнорировать ошибки и продолжать выполнение. Это режим обработки ошибок по умолчанию.
- `"error_mode: propagate"` говорит процессору вернуть ошибку. В результате Collector откажется от данных.

### Расширенные функции

- Вы также можете использовать процессор преобразования, чтобы изменять имена спанов на основе атрибутов спана или извлекать атрибуты спана из имени спана. Для примеров смотрите пример [файла конфигурации процессора преобразования](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/9b28f76c02c18f7479d10e4b6a95a21467fd85d6/processor/transformprocessor/testdata/config.yaml).
- [Процессор преобразования](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/transformprocessor) также предлагает расширенные возможности преобразования атрибутов. Процессор преобразования позволяет конечным пользователям задавать преобразования для метрик, журналов и трассировок, используя [Язык преобразования OpenTelemetry (OTTL)](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/pkg/ottl).
- Для получения дополнительной информации о функциях и синтаксисе OTTL смотрите:
  - Синтаксис OTTL: [https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/pkg/ottl/README.md](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/pkg/ottl/README.md)
  - Функции OTTL: [https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/pkg/ottl/ottlfuncs](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/pkg/ottl/ottlfuncs)
  - Контексты OTTL: [https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/pkg/ottl/contexts](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/pkg/ottl/contexts)

## Экспортёры

Экспортёры отправляют данные в один или несколько бэкендов или конечных точек. Экспортёры могут быть основаны на принципе выборки или отправки и могут поддерживать один или несколько [источников данных](https://opentelemetry.io/docs/concepts/signals/).

Вы можете настроить экспортёры в разделе `exporters` файла конфигурации Collector. Большинство экспортёров требуют как минимум конечную точку и настройки безопасности, такие как аутентификационные токены или TLS сертификаты. Любые указанные вами настройки переопределят значения по умолчанию (если они существуют).

**Примечание**: Настройка экспортёра не включает его. Экспортёр необходимо включить, добавив его в соответствующий конвейер в [разделе службы](#service-section). По умолчанию ни один экспортёр не включен.

Для Collector требуется один или несколько экспортёров. Ниже приведены общие примеры конфигурации экспортёров:

**Совет**: Некоторые экспортёры требуют сертификаты x.509 для установления защищённого соединения, как описано в [Настройка сертификатов](#configuring-certificates). Для более подробных конфигураций экспортёров смотрите [README экспортёра](https://github.com/open-telemetry/opentelemetry-collector/blob/main/exporter/README.md).

### **Экспортёр OTLP**

Экспортёр OTLP отправляет метрики, трассировки и журналы, используя формат OTLP через gRPC. Поддерживаемые типы конвейеров включают спаны, метрики и журналы. По умолчанию этот экспортёр требует TLS и предлагает функциональность повторной очереди.
Для отправки данных OTLP через HTTP используйте экспортёр OTLP/HTTP. Смотрите экспортёр OTLP/HTTP для инструкций.

**YAML пример**

```yaml
config: |
  exporters:
    otlp:
      endpoint: tempo-ingester:4317
      tls:
        ca_file: ca.pem
        cert_file: cert.pem
        key_file: key.pem
        insecure: false
        insecure_skip_verify: false
        reload_interval: 1h
        server_name_override: <name>
      headers:
        X-Scope-OrgID: "dev"
  service:
    pipelines:
      traces:
        exporters: [otlp]
      metrics:
        exporters: [otlp]
```

**Описание параметров `otlp`**

| Параметр                  | Описание                                                                                                                                                                                      |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `endpoint`                 | Конечная точка OTLP gRPC. Если используется схема `https://`, активируется безопасность клиентского транспорта и переопределяются небезопасные настройки в `tls`.                                          |
| `tls`                      | Конфигурация клиентского TLS. Определяет пути к сертификатам TLS.                                                                                                                                 |
| `tls.insecure`             | При установленном в `true` отключает безопасность клиентского транспорта. По умолчанию `false`.                                                                                                  |
| `tls.insecure_skip_verify` | При установленном в `true` пропускает проверку сертификата. По умолчанию `false`.                                                                                                              |
| `tls.reload_interval`      | Указывает интервал, в течение которого сертификаты перезагружаются. Если не установлен, сертификаты никогда не будут перезагружены. Принимает строку с допустимыми единицами времени, такими как `ns`, `us` (или `µs`), `ms`, `s`, `m`, `h`. |
| `tls.server_name_override` | Переопределяет авторитетное виртуальное доменное имя, например поле заголовка `authority` в запросах. Может быть использовано для тестирования.                                                      |
| `headers`                  | Заголовки, отправляемые с каждым запросом во время установленного соединения.                                                                                                             |

### **Экспортёр OTLP HTTP**

Экспортёр OTLP HTTP экспортирует трассировки и метрики с использованием Протокола OpenTelemetry (OTLP).

**YAML пример**

```yaml
  config: |
    exporters:
      otlphttp:
        endpoint: http://tempo-ingester:4318
        tls:
        headers:
          X-Scope-OrgID: "dev"
        disable_keep_alives: false

    service:
      pipelines:
        traces:
          exporters: [otlphttp]
        metrics:
          exporters: [otlphttp]
```

**Описание параметров `otlphttp`**

| Параметр             | Описание                                                                                                                                |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| `endpoint`            | Конечная точка OTLP HTTP. Если используется схема `https://`, активируется безопасность клиентского транспорта и переопределяются любые небезопасные настройки в `tls`. |
| `tls`                 | Конфигурация клиентского TLS. Определяет путь для сертификатов TLS.                                                                   |
| `headers`             | Заголовки, отправляемые с каждым запросом HTTP.                                                                                         |
| `disable_keep_alives` | Если установлен в `true`, HTTP keep-alives отключены. Будет сделан только один HTTP-запрос на каждое соединение с сервером.              |

### **Экспортёр Debug**

Экспортёр Debug выводит телеметрические данные в консоль для целей отладки.

**YAML пример**

```yaml
  config: |
    exporters:
      debug:
        verbosity: detailed
    service:
      pipelines:
        traces:
          exporters: [logging]
        metrics:
          exporters: [logging]
```

Поле `debug.verbosity` управляет уровнем детализации записей экспортируемых данных (`detailed|normal|basic`). При установленном в `detailed`, данные конвейера регистрируются в деталях.

### **Экспортёр балансировки нагрузки**

Экспортёр балансировки нагрузки может экспортировать спаны, метрики и журналы в несколько бэкендов. Поддерживаемые типы конвейеров включают метрики, спаны и журналы. Экспортёр балансировки нагрузки может использовать политики маршрутизации для одновременной отправки телеметрических данных в несколько бэкендов. Вы можете настроить `routing_key`, чтобы использовать политики маршрутизации для классификации телеметрических данных в группы и сопоставления этих групп с определенными конечными точками.

С помощью экспортёра балансировки нагрузки вы также можете отправлять данные в другие работающие экземпляры OpenTelemetry Collector через конечные точки сборщика. Например, вы можете отправить все трассировки в один экземпляр коллектора и все журналы в другой экземпляр. Это позволяет обрабатывать или манипулировать вашими данными в разных средах коллектора.

**YAML пример**

```yaml
  config: |
    exporters:
      loadbalancing:
        routing_key: "service"
        protocol:
          otlp:
            timeout: 1s
        resolver:
          static:
            hostnames:
            - backend-1:4317
            - backend-2:4317
          dns:
            hostname: otelcol-headless.observability.svc.cluster.local
          k8s:
            service: lb-svc.kube-public
            ports:
              - 15317
              - 16317
```

**Описание параметров `loadbalancing`**

| Параметр         | Описание                                                                                                                                                                                                                              |
| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `routing_key`     | `"routing_key: service"` экспортирует спаны с одинаковым именем службы в тот же экземпляр Collector для точной агрегации. `"routing_key: traceID"` экспортирует спаны на основе их TraceID. Неявный по умолчанию — это маршрутизация на основе TraceID. |
| `protocol.otlp`   | OTLP — единственный поддерживаемый протокол балансировки нагрузки. Поддерживаются все настройки экспортёра OTLP.                                                                                                                                                                                             |
| `resolver`        | Можно настроить только один резольвер.                                                                                                                                                                                                  |
| `resolver.static` | Статический резольвер распределяет нагрузку между перечисленными конечными точками.                                                                                                                                                    |
| `resolver.dns`    | DNS-резольвер применим только к Kubernetes ядрам.                                                                                                                                                                                     |
| `resolver.k8s`    | Резольвер Kubernetes рекомендуется.                                                                                                                                                                                                   |

### **Экспортёр Prometheus**

Экспортёр Prometheus экспортирует данные метрик в формате Prometheus или OpenMetrics, что позволяет серверам Prometheus извлекать данные. Ниже приведены детали для настройки и использования экспортёра Prometheus.

**Обязательная конфигурация**

- **endpoint**: Указывает адрес для публичного отображения данных метрик с путём `/metrics`. Это должно быть настроено и не имеет значения по умолчанию.

**Опциональная конфигурация**

- **const_labels**: Пары ключ-значение меток, применяемых к каждой экспортируемой метрике, по умолчанию не установлены.
- **namespace**: Если установлен, все экспортируемые метрики будут использовать это пространство имён, без значения по умолчанию.
- **send_timestamps**: Отправлять ли временные метки для выборок метрик в ответе, по умолчанию `false`.
- **metric_expiration**: Определяет, как долго метрики будут отображаться без обновлений, по умолчанию `5m`.
- **resource_to_telemetry_conversion**:
  - `enabled`: По умолчанию `false`. При включении атрибуты ресурсов преобразуются в метки метрик.
- **enable_open_metrics**: По умолчанию `false`. При включении метрики экспортируются с использованием формата OpenMetrics.
- **add_metric_suffixes**: По умолчанию `true`. Добавлять ли суффиксы типа и единицы измерения.

**Конфигурация TLS**

TLS сертификаты могут быть установлены с использованием `ca_file`, `cert_file` и `key_file` для обеспечения защищенной связи.

**Пример конфигурации YAML**

Ниже приведен пример конфигурации для экспортёра Prometheus:

```yaml
exporters:
  prometheus:
    endpoint: "0.0.0.0:8889"
    tls:
      ca_file: "/path/to/ca.pem"
      cert_file: "/path/to/cert.pem"
      key_file: "/path/to/key.pem"
    namespace: "prefix"
    const_labels:
      label1: "value1"
    send_timestamps: true
    metric_expiration: "180m"
    enable_open_metrics: true
    add_metric_suffixes: false
    resource_to_telemetry_conversion:
      enabled: true
```

Эта конфигурация открывает метрики Prometheus на `0.0.0.0:8889/metrics` и настраивает сертификаты TLS и другие параметры.

**Рекомендации по использованию**

1. В OpenTelemetry имена метрик и меток стандартизированы в соответствии с правилами именования Prometheus.
2. По умолчанию атрибуты ресурсов добавляются к метрике `target_info`. Вы можете использовать запросы Prometheus для выбора и группировки этих атрибутов в качестве меток метрик.
3. Чтобы упростить запросы и группировку, рекомендуется использовать `преобразователь процессор`, чтобы напрямую преобразовать часто используемые атрибуты ресурсов в метки метрик.

## Соединители

Соединители связывают два конвейера, действуя одновременно как экспортёры и приемники. Соединитель потребляет данные как экспортёр в конце одного конвейера и отправляет данные как приемник в начале другого конвейера. Потребляемые и отправляемые данные могут быть одного и того же типа или различного. Вы можете использовать соединители для агрегации, дублирования или маршрутизации данных.

Вы можете настроить один или несколько соединителей в разделе `connectors` файла конфигурации Collector. По умолчанию ни один соединитель не настроен. Каждый тип соединителя предназначен для обработки комбинации одного или нескольких типов данных и может использоваться только для соединения соответствующих типов данных конвейеров.

**Примечание**: Настройка соединителя не включает его. Соединители должны быть включены, добавив их в соответствующие конвейеры в [разделе службы](#service-section).

**Совет**: Для более подробной конфигурации соединителей смотрите [README соединителя](https://github.com/open-telemetry/opentelemetry-collector/blob/main/connector/README.md).

### **Соединитель графа службы ASM**

Соединитель графа службы ASM создает карту, представляющую отношения между различными службами в системе. Этот соединитель анализирует данные спанов и генерирует метрики, описывающие отношения между службами. Эти метрики могут быть использованы приложениями для визуализации данных (такими как Grafana) для построения графа служб.

**Примечание:** Этот компонент является пользовательской версией компонента сообщества Соединитель графа служб и не может быть заменен напрямую компонентом нативного сообщества. Специфические параметры различий объясняются ниже.

Топологии служб очень полезны во многих случаях использования:

- Выяснение топологии распределенной системы. Поскольку распределенные системы растут, они становятся все более сложными. Графы служб помогают вам понять структуру системы.
- Предоставление общего обзора состояния системы. Графы служб отображают уровни ошибок, задержки и другие важные данные.
- Предоставление исторического взгляда на топологию системы. Распределенные системы часто меняются, и графы служб предоставляют способ увидеть, как эти системы развиваются со временем.

**YAML пример**

```yaml
  config: |
    connectors:
      asmservicegraph:
        dimensions: []
        extra_dimensions:
          mesh_id:
          cluster_name:
        store:
          ttl: 5s
          max_items: 500
```

**Описание параметров `asmservicegraph`**

| Параметр                       | Описание                                                                                                  |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| `dimensions`                    | Дополнительные измерения (метки) для добавления к метрикам, извлекаемым из атрибутов ресурсов и спанов.            |
| `extra_dimensions`              | Атрибуты, добавленные платформой ASM.                                                                        |
| `extra_dimensions.mesh_id`      | ID сетки. Платформа ASM разворачивает сетку Istio, и mesh_id отражает ID даннной сетки Istio.                  |
| `extra_dimensions.cluster_name` | Имя кластера. Имя кластера, в котором находится OTel Collector в рамках платформы ASM.                       |
| `store.ttl`                     | Время жизни временных данных в хранилище памяти.                                                            |
| `store.max_items`               | Максимальное количество записей данных спанов, которые могут быть временно сохранены в памяти.                |

## Расширения

Расширения добавляют возможности в Collector. Например, расширения могут автоматически добавлять функции аутентификации к приемникам и экспортёрам.

Расширения являются необязательными компонентами, используемыми для расширения функционала Collector для задач, не связанных с обработкой телеметрических данных. Например, вы можете добавить расширения для мониторинга состояния, обнаружения сервисов или пересылки данных.

Вы можете настроить расширения в разделе `extensions` файла конфигурации Collector. Большинство расширений поставляется с настройками по умолчанию, поэтому вам нужно только указать имя расширения, чтобы настроить его. Любые указанные настройки переопределят значения по умолчанию (если они существуют).

**Примечание**: Настройка расширения не включает его. Расширения необходимо включить в [разделе службы](#service-section). По умолчанию ни одно расширение не настроено.

**Совет**: Для более подробной конфигурации расширений смотрите [README расширения](https://github.com/open-telemetry/opentelemetry-collector/blob/main/extension/README.md).

## Раздел службы

Раздел `service` используется для включения компонентов в Collector на основе конфигурации в разделах `receivers`, `processors`, `exporters` и `extensions`. Если компонент настроен, но не определен в разделе `service`, он не будет включен.

Раздел `service` включает три подсекции:

1. **Расширения**: Список необходимых расширений для включения. Например:

   ```yaml
   service:
     extensions: [health_check, pprof, zpages]
   ```

2. **Конвейеры**: Настраивает конвейеры, которые могут быть следующих типов:

   - **traces**: Собирает и обрабатывает данные трассировки.
   - **metrics**: Собирает и обрабатывает данные метрик.
   - **logs**: Собирает и обрабатывает журнальные данные.

   Конвейер состоит из набора `receivers`, `processors` и `exporters`. Прежде чем включить `receiver`, `processor` или `exporter` в конвейер, убедитесь, что его конфигурация определена в соответствующих разделах.

   Вы можете использовать один и тот же `receiver`, `processor` или `exporter` в нескольких конвейерах. Когда процессор упоминается в нескольких конвейерах, каждый конвейер получает отдельный экземпляр этого процессора.

   Вот пример конфигурации конвейера. Обратите внимание, что порядок процессоров определяет последовательность обработки данных:

   ```yaml
   service:
     pipelines:
       metrics:
         receivers: [opencensus, prometheus]
         processors: [batch]
         exporters: [opencensus, prometheus]
       traces:
         receivers: [opencensus, jaeger]
         processors: [batch, memory_limiter]
         exporters: [opencensus, zipkin]
   ```

3. **Телеметрия**: Раздел конфигурации `telemetry` используется для настройки наблюдаемости самого Collector. Он состоит из подразделов `logs` и `metrics`. Для получения информации о том, как настроить эти сигналы, смотрите [Активация внутренней телеметрии в Collector](https://opentelemetry.io/docs/collector/internal-telemetry/#activate-internal-telemetry-in-the-collector).

## Дополнительная информация

### Переменные окружения

Конфигурации Collector поддерживают использование и расширение переменных окружения. Например, чтобы использовать значения, хранящиеся в переменных окружения `DB_KEY` и `OPERATION`, вы можете записать:

```yaml
processors:
  attributes/example:
    actions:
      - key: ${env:DB_KEY}
        action: ${env:OPERATION}
```

Используйте `$$`, чтобы представить литерал `$`. Например, чтобы представить `$DataVisualization`, вы можете записать:

```yaml
exporters:
  prometheus:
    endpoint: prometheus:8889
    namespace: $$DataVisualization
```

### Поддержка прокси

Экспортёры, использующие пакет [net/http](https://pkg.go.dev/net/http), поддерживают следующие переменные окружения для прокси:

- **HTTP_PROXY**: Адрес HTTP-прокси.
- **HTTPS_PROXY**: Адрес HTTPS-прокси.
- **NO_PROXY**: Адреса, для которых следует обходить прокси.

Если эти переменные установлены, когда Collector запускается, экспортёры будут проксировать или обходить прокси-трафик в соответствии с этими переменными окружения, независимо от протокола.

### Аутентификация

Большинство `receivers`, открывающих HTTP или gRPC порты, можно защитить с помощью механизмов аутентификации Collector. Аналогично, большинство `exporters`, использующих HTTP или gRPC клиентов, могут добавлять аутентификацию к исходящим запросам.

Механизм аутентификации в Collector использует механизм расширений, позволяя интегрировать пользовательские аутентификаторы в распространение Collector. Каждый аутентификатор расширения может быть использован двумя способами:

1. Как клиентский аутентификатор для `exporters`, добавляя данные аутентификации к исходящим запросам.
2. Как серверный аутентификатор для `receivers`, аутентифицируя входящие подключения.

Для получения списка известных аутентификаторов смотрите [Реестр](https://opentelemetry.io/ecosystem/registry/?s=authenticator\&component=extension).

Чтобы добавить серверный аутентификатор к `receiver` в Collector, выполните следующие шаги:

1. Добавьте расширение аутентификатора и его конфигурацию в разделе `.extensions`.
2. Добавьте ссылку на аутентификатор в разделе `.services.extensions`, чтобы Collector его загрузил.
3. Добавьте ссылку на аутентификатор в разделе `.receivers.<ваш-приемник>.<http-or-grpc-config>.auth`.

Следующий пример использует аутентификатор OIDC на стороне получения, подходящий для удаленных Collectors, получающих данные через OpenTelemetry Collector в качестве прокси:

```yaml
extensions:
  oidc:
    issuer_url: http://localhost:8080/auth/realms/opentelemetry
    audience: collector

receivers:
  otlp/auth:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
        auth:
          authenticator: oidc

processors:

exporters:
  # Примечание: Используйте `logging`, а не `debug` до версии v0.86.0.
  debug:

service:
  extensions:
    - oidc
  pipelines:
    traces:
      receivers:
        - otlp/auth
      processors: []
      exporters:
        - debug
```

На стороне прокси этот пример настраивает экспортёр OTLP для получения токенов OIDC и добавления их в каждый RPC, отправляемый удаленному Collector:

```yaml
extensions:
  oauth2client:
    client_id: agent
    client_secret: some-secret
    token_url: http://localhost:8080/auth/realms/opentelemetry/protocol/openid-connect/token

receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317

processors:

exporters:
  otlp/auth:
    endpoint: remote-collector:4317
    auth:
      authenticator: oauth2client



service:
  extensions:
    - oauth2client
  pipelines:
    traces:
      receivers:
        - otlp
      processors: []
      exporters:
        - otlp/auth
```

### Настройка сертификатов

Для обеспечения безопасности коммуникации в производственных средах используйте сертификаты TLS или mTLS для взаимной аутентификации. Следуйте этим шагам для генерации самоподписанного сертификата, или используйте своего текущего поставщика сертификатов для производственных сертификатов.

Установите [cfssl](https://github.com/cloudflare/cfssl) и создайте следующий файл `csr.json`:

```json
{
  "hosts": ["localhost", "127.0.0.1"],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "O": "OpenTelemetry Example"
    }
  ]
}
```

Затем выполните следующие команды:

```bash
cfssl genkey -initca csr.json | cfssljson -bare ca
cfssl gencert -ca ca.pem -ca-key ca-key.pem csr.json | cfssljson -bare cert
```

Это создаст два сертификата:

1. Сертификат удостоверяющего центра (CA) с именем "OpenTelemetry Example", хранящийся в `ca.pem`, с сопутствующим ключом в `ca-key.pem`.
2. Сертификат клиента, хранящийся в `cert.pem`, подписанный удостоверяющим центром OpenTelemetry Example, с сопутствующим ключом в `cert-key.pem`.

## Переопределение настроек

Вы можете переопределить настройки Collector с помощью опции `--set`. Настройки, определенные таким образом, будут объединены в окончательную конфигурацию после разрешения и объединения всех источников `--config`.

Следующий пример показывает, как переопределить настройки в вложенных разделах:

```bash
otelcol --set "exporters::debug::verbosity=detailed"
otelcol --set "receivers::otlp::protocols::grpc={endpoint:localhost:4317, compression: gzip}"
```

**Важно:** Опция `--set` не поддерживает установку ключей, содержащих точки (.) или знаки равенства (=).
